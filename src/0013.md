数组的总结

# 0. 创建数组

``` js
// bad
var arr = new Array(1, 2);

// good
var arr = [1, 2];
```

# 1. for循环

``` js
var a = [1, 2, 3];

// for循环
for(var i = 0; i < a.length; i++) {
  console.log(a[i]);
}
```

# 2. for ... of

一个数据结构只要部署了Symbol.iterator属性（可遍历），就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员

``` js
const arr = ['red', 'green', 'blue'];

for(let v of arr) {
  console.log(v); // red green blue
}
```

``` js
const arr = [
  {name: 'jake', age: 18},
  {name: 'joy', age: 19},
  {name: 'mike', age: 20},
  {name: 'tom', age: 21}
]

for(let item of arr) {
  console.log(item);
  // {name: 'jake', age: 18},
  // {name: 'joy', age: 19},
  // {name: 'mike', age: 20},
  // {name: 'tom', age: 21}
}
```

1. 无法遍历对象(对象无interator接口)在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments 对象等等

2. 结果是数据的每一项

3. 不会遍历自定义属性

``` js
Object.prototype.objCustom = function() {}; 
Array.prototype.arrCustom = function() {};

let iterable = [3, 5, 7];
iterable.foo = 'hello';

for (let i in iterable) {
  console.log(i); // 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) { 
  if (iterable.hasOwnProperty(i)) {
    // 所以不推荐使用for...in遍历数组，会多出 foo 这个
    console.log(i); // 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}

```

# 3. 判断一个 object 是否是数组

1. Array.isArray

``` js
var arr = [1, 2, 3];

typeof arr // "object"
Array.isArray(arr) // true
```

2. Object.prototype.toString

这里使用 call 来使 toString 中 this 指向 obj。进而完成判断
```js
function isArray(obj){
 return Object.prototype.toString.call( obj ) === '[object Array]';
}
```

3. 原型链

基本思想: 实例如果是某个构造函数构造出来的那么 它的 `__proto__` 是指向构造函数的 prototype属性

```js
function isArray(obj){
 return obj.__proto__ === Array.prototype;
}
```



# 4. push()，pop() -- 改变原数组

``` js
var arr = [];

arr.push(1) // 1 返回数组长度1
arr.push('a') // 2 返回数组长度2
arr.push(true, {}) // 4  返回数组长度4
arr // [1, 'a', true, {}]  原数组被改变
```

``` js
var arr = ['a', 'b', 'c'];

arr.pop() // 'c' 返回被删除的元素c
arr // ['a', 'b']   原数组被改变
```

后进先出”的栈结构（stack）

``` js
var arr = [];
arr.push(1, 2);
arr.push(3);
arr.pop();
arr // [1, 2]
```

# 5. shift()，unshift() -- 改变原数组

``` js
let a = ['a', 'b', 'c'];

a.shift() // 'a'  返回被删除的元素
a // ['b', 'c']
```

# 6. join()

``` js
let a = [1, 2, 3, 4];

a.join(' ') // '1 2 3 4'
a.join(' | ') // "1 | 2 | 3 | 4"
a.join() // "1,2,3,4"  默认用逗号分隔

[undefined, null].join('#') // '#'  如果数组成员是undefined或null或空位，会被转成空字符串

['a',, 'b'].join('-') // 'a--b'  如果数组成员是undefined或null或空位，会被转成空字符串
```

通过call方法，这个方法也可以用于字符串或类似数组的对象。

``` js
Array.prototype.join.call('hello', '-')
// "h-e-l-l-o"

var obj = { 0: 'a', 1: 'b', length: 2 };
Array.prototype.join.call(obj, '-')
// 'a-b'
```

# 7. concat() -- 返回一个新数组，原数组不变

``` js
['hello'].concat(['world'])
// ["hello", "world"]

['hello'].concat(['world'], ['!'])
// ["hello", "world", "!"]

[].concat({a: 1}, {b: 2})
// [{ a: 1 }, { b: 2 }]

[2].concat({a: 1})
// [2, {a: 1}]
```

除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。

``` js
[1, 2, 3].concat(4, 5, 6)
// [1, 2, 3, 4, 5, 6]
```

如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。

``` js
var obj = { a: 1 };
var oldArray = [obj];

var newArray = oldArray.concat();

obj.a = 2;
newArray[0].a // 2
```

# 8. reverse() -- 改变原数组

``` js
let a = ['a', 'b', 'c'];

a.reverse() // ["c", "b", "a"]
a // ["c", "b", "a"]
```

# 9. slice() -- 不改变

提取目标数组的一部分，返回一个新数组，**浅拷贝数组的元素**

> 字符串也有一个 slice() 方法是用来提取字符串的，不要弄混了。

``` js
 let a = [{name: 'OBKoro1'}, {name: 'zhangsan'}];
 let b = a.slice(0,1);
 console.log(b, a);  // [{"name":"OBKoro1"}]  [{"name":"OBKoro1"}]
 a[0].name='改变原数组';
 console.log(b,a); // [{"name":"改变原数组"}] [{"name":"改变原数组"}]
```

slice()方法的一个重要应用，是将类似数组的对象转为真正的数组。

``` js
Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
// ['a', 'b']

Array.prototype.slice.call(document.querySelectorAll("div"));
Array.prototype.slice.call(arguments);
```


# 10. splice() -- 改变原数组

删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。

``` js
let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0, 3); // [1,2,3] // 从数组下标0开始，删除3个元素
console.log(a); // [4,5,6,7]

let item1 = a.splice(0,3,'添加'); // [4,5,6] // 从数组下标0开始，删除3个元素，并添加元素'添加'
console.log(a); // ['添加',7]

```

# 11. sort() -- 改变原数组

sort方法对数组成员进行排序，默认是按照字典顺序排序。

``` js
['d', 'c', 'b', 'a'].sort()
// ['a', 'b', 'c', 'd']

[4, 3, 2, 1].sort()
// [1, 2, 3, 4]

[11, 101].sort()
// [101, 11]  数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。

[10111, 1101, 111].sort()
// [10111, 1101, 111]  数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。


[10111, 1101, 111].sort(function (a, b) {
  return a - b;  // 大于0，表示第一个成员排在第二个成员后面
})
// [111, 1101, 10111]
```

``` js
[
  { name: "张三", age: 30 },
  { name: "李四", age: 24 },
  { name: "王五", age: 28  }
].sort(function (o1, o2) {
  return o1.age - o2.age;
})
// [
//   { name: "李四", age: 24 },
//   { name: "王五", age: 28  },
//   { name: "张三", age: 30 }
// ]
```


# 12. map()
运行结果组成一个新数组返回，原数组没有变化。

``` js
var numbers = [1, 2, 3];

numbers.map(function (n, index, numbers) {
  return n + 1;
});
// [2, 3, 4]

numbers
// [1, 2, 3]
```

map()方法的第二个参数，将回调函数内部的this对象，指向arr数组

``` js
var arr = ['a', 'b', 'c'];

[1, 2].map(function (e) {
  return this[e];
}, arr)
// ['b', 'c']
```

map()方法不会跳过undefined和null，但是会跳过空位

``` js
var f = function (n) { return 'a' };

[1, undefined, 2].map(f) // ["a", "a", "a"]
[1, null, 2].map(f) // ["a", "a", "a"]
[1, , 2].map(f) // ["a", , "a"]
```


# 13. forEach()

如果数组遍历的目的是为了得到返回值，那么使用map()方法，否则使用forEach()方法。

forEach()方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。

```js
function log(element, index, array) {
  console.log('[' + index + '] = ' + element);
}

[2, 5, 9].forEach(log);
// [0] = 2
// [1] = 5
// [2] = 9
```

# 15. filter()

满足条件的成员组成一个新数组返回。

``` js
[1, 2, 3, 4, 5].filter(function (elem) {
  return (elem > 3);
})
// [4, 5]
```

# 16. some()，every()

返回一个布尔值，表示判断数组成员是否符合某种条件。

``` js
var arr = [1, 2, 3, 4, 5];
arr.some(function (elem, index, arr) {
  return elem >= 3;
});
// true 只要有一个满足就返回true
```

``` js
var arr = [1, 2, 3, 4, 5];
arr.every(function (elem, index, arr) {
  return elem >= 3;
});
// false  必须所有的都满足才返回true
```

注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。

``` js
function isEven(x) { return x % 2 === 0 }

[].some(isEven) // false
[].every(isEven) // true
```

# 16. reduce()，reduceRight() 

reduce是从左到右处理（从第一个成员到最后一个成员）

``` js
[1, 2, 3, 4, 5].reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15
```

如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。

``` js
[1, 2, 3, 4, 5].reduce(function (a, b) {
  return a + b;
}, 10);
// 25


function add(prev, cur) {
  return prev + cur;
}

[].reduce(add)
// TypeError: Reduce of empty array with no initial value
[].reduce(add, 1)
// 1
```

找出字符长度最长的数组成员

``` js
function findLongest(entries) {
  return entries.reduce(function (longest, entry) {
    return entry.length > longest.length ? entry : longest;
  }, '');
}

findLongest(['aaa', 'bb', 'c']) // "aaa"
```

# 17. indexOf()，lastIndexOf() --  includes()

在es7中我们使用 inclueds 来判断数组中是否包含某个元素

``` js
let a = ['a', 'b', 'c'];

a.inclues('b') // true

if(a.inclues('b')){ ... }
```

indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。

``` js
let a = ['a', 'b', 'c'];

a.indexOf('b') // 1
a.indexOf('y') // -1

if(a.indexOf('b') > -1) { ... }   //  这个更简洁
```

indexOf方法还可以接受第二个参数，表示搜索的开始位置。

``` js
['a', 'b', 'c'].indexOf('a', 1) // -1
```

lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。

``` js
var a = [2, 5, 9, 2];
a.lastIndexOf(2) // 3
a.lastIndexOf(7) // -1
```

注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。

这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。

``` js
[NaN].indexOf(NaN) // -1
[NaN].lastIndexOf(NaN) // -1
```

# 18. 链式使用

``` js
var users = [
  {name: 'tom', email: 'tom@example.com'},
  {name: 'peter', email: 'peter@example.com'}
];

users
.map(function (user) {
  return user.email;
})
.filter(function (email) {
  return /^t/.test(email);
})
.forEach(function (email) {
  console.log(email);
});
// "tom@example.com"
```


# 19. find()、 findIndex()

获取数组中年龄大于 18 的第一个元素

这两个方法都可以识别 NaN,弥补了 indexOf 的不足.

``` js
[1, 4, -5, 10,NaN].find((n) => Object.is(NaN, n)); 
// 返回元素NaN
[1, 4, -5, 10].findIndex((n) => n < 0); 
// 返回索引2
```

如果没有符合条件的元素返回 undefined

find() 对于空数组，函数是不会执行的。


# 20. while 、 do while

do while先执行后判断，循环至少执行一次，即便条件为false

while先判断后执行

```js
var a = [1, 2, 3];

var i = 0;
while (i < a.length) {
  console.log(a[i]);
  i++;
}

var l = a.length;
while (l >= 0) {
  console.log(a[l]);
  l--
}
```

```js
let i = 2;

do {
  console.lg(i);  // 2
  i++
} while (i < 2) {
  console.log(i);   // 3
}
```


# 21. copyWithin() -- 改变原数组

指定位置的成员复制到其他位置

``` js
 let a = ['zhang', 'wang', 'zhou', 'wu', 'zheng'];
 // 1位置开始被替换, 2位置开始读取要替换的  5位置前面停止替换
 a.copyWithin(1, 2, 5);
 // ["zhang", "zhou", "wu", "zheng", "zheng"]
```


# 22. fill() -- 改变原数组

填充数组

``` js
['a', 'b', 'c'].fill(7)
// [7, 7, 7]
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```


# 23. cancat()

合并两个或多个数组

```js
let a = [1, 2, 3];
let b = [4, 5, 6];
//连接两个数组
let newVal=a.concat(b); // [1,2,3,4,5,6]
```


# 24. 扩展运算符

``` js
let a = [2, 3, 4, 5]
let b = [ 4,...a, 4, 4]
console.log(a,b); 
//[2, 3, 4, 5] [4,2,3,4,5,4,4]
```


# 25. keys()、values()、entries()

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1    
for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'    
for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```


